<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MP4 Dataset Cutter</title>
  <link rel="stylesheet" href="/static/style.css" />
  <link rel="icon" href="/assets/AppIcon.appiconset/mac32.png" sizes="32x32" />
  <link rel="icon" href="/assets/AppIcon.appiconset/iphone120.png" sizes="120x120" />
</head>

<body>
  <div id="app">
    <header>
      <div class="brand">
        <img src="/assets/AppIcon.appiconset/mac64.png" alt="icon" class="brand-icon" />
        <h1 class="app-title">MP4 Dataset Cutter</h1>
      </div>
      <div class="settings">
        <label>
          Dataset Root:
          <input type="text" id="datasetRoot" placeholder="dataset/" />
        </label>
        <label>
          Clip Duration (s):
          <input type="number" id="clipDuration" min="0.5" step="0.1" value="4.0" />
        </label>
        <label
          title="Backward: last N seconds ending at the current time. Centered: N/2 before and after. Range: uses I/O marks.">
          Mode:
          <select id="clipMode">
            <option value="backward">Past N sec (end at cursor)</option>
            <option value="centered">Centered (±N/2)</option>
            <option value="range">In/Out range</option>
          </select>
        </label>
        <label title="Target number of clips per label for coloring">
          Threshold:
          <input type="number" id="labelThreshold" min="1" step="1" value="50" />
        </label>
        <label title="± margin around threshold counted as 'warn'">
          Margin:
          <input type="number" id="labelMargin" min="0" step="1" value="5" />
        </label>
        <label>
          Native controls
          <input type="checkbox" id="toggleControls" />
        </label>
        <button id="saveSettings">Save</button>
        <button id="refreshStats" title="Recompute counts and recolor quick labels">Refresh Stats</button>
        <button id="quitServer" title="Stop the local DatasetCutter server">Quit Server</button>
      </div>
    </header>

    <div class="shortcuts shortcuts-banner" aria-label="Keyboard shortcuts">
      <span class="pill">Space: Play/Pause</span>
      <span class="pill">Enter: Clip</span>
      <span class="pill">Digits: Quick Labels (multi-digit OK)</span>
      <span class="pill">←/→: Seek ±0.25s (Shift=±1s)</span>
      <span class="pill">J/K/L: 0.5x/1.0x/1.5x</span>
      <span class="pill">U: Undo</span>
      <span class="pill">I/O: Mark In/Out</span>
      <span class="pill">C: Clip Range</span>
    </div>

    <main>
      <section class="left">
        <div class="video-controls">
          <input type="file" id="fileInput" accept="video/mp4,video/quicktime,video/*" />
          <button id="openBtn">Open Video</button>
          <select id="videoList"></select>
          <div class="current-filename shortcuts-inline" aria-label="Current movie">
            <span id="fileName"></span>
          </div>
        </div>

        <div class="player">
          <video id="player" preload="metadata"></video>
          <div class="timeline">
            <input type="range" id="seek" min="0" max="1000" value="0" />
            <div class="marks">
              <span id="timeLabel">00:00.00 / 00:00.00</span>
              <span id="markIn">I: --</span>
              <span id="markOut">O: --</span>
            </div>
          </div>
          <div class="buttons">
            <button id="btnBack">-1s</button>
            <button id="btnBackSmall">-0.25s</button>
            <button id="btnPlay">Play/Pause</button>
            <button id="btnFwdSmall">+0.25s</button>
            <button id="btnFwd">+1s</button>
            <button id="btnSpeed">1.0x</button>
            <button id="btnSetIn">Set In (I)</button>
            <button id="btnSetOut">Set Out (O)</button>
            <button id="btnClipRange">Clip Range (C)</button>
            <button id="btnUndo">Undo</button>
          </div>
        </div>
      </section>

      <section class="right">
        <div class="labeling">
          <div class="label-header">
            <h3>Label</h3>
            <div id="labelMiniChart" aria-label="Label counts chart"></div>
          </div>
          <input id="labelInput" placeholder="Type a label" list="labelsDatalist" />
          <datalist id="labelsDatalist"></datalist>
          <div id="quickLabels"></div>
          <div class="hint hint-small">Hotkeys: digits for quick labels (supports multi-digit like 10, 11).</div>
        </div>
        <div class="log" id="log"></div>
      </section>
    </main>

    <!-- Footer removed; shortcuts moved below header to full width -->
  </div>

  <!-- Label modal (autocomplete using existing datalist) -->
  <div id="labelModalBackdrop" class="modal-backdrop" style="display:none">
    <div class="modal">
      <h3>Label</h3>
      <input id="labelModalInput" list="labelsDatalist" placeholder="Type or pick a label" />
      <div class="modal-actions">
        <button id="labelModalOk">OK</button>
        <button id="labelModalCancel">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const settings = { dataset_root: '', clip_duration: 4.0, clip_mode: 'backward', target_per_label: 50, margin_per_label: 5 };
    const el = (id) => document.getElementById(id);
    const player = el('player');
    const seek = el('seek');
    const labelInput = el('labelInput');
    const timeLabel = el('timeLabel');
    const fileName = el('fileName');

    let currentVideo = null;
    let lastLabels = [];
    let markIn = null, markOut = null;
    let isSeeking = false;
    let wasPlaying = false;
    let digitBuffer = '';
    let digitTimer = null;

    function fmt(t) {
      if (!isFinite(t)) return '00:00.00';
      const m = Math.floor(t / 60);
      const s = Math.floor(t % 60);
      const cs = Math.floor((t * 100) % 100);
      return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}.${String(cs).padStart(2, '0')}`;
    }

    async function fetchSettings() {
      const r = await fetch('/api/settings');
      const s = await r.json();
      settings.dataset_root = s.dataset_root;
      settings.clip_duration = s.clip_duration;
      settings.clip_mode = s.clip_mode;
      settings.target_per_label = s.target_per_label || settings.target_per_label;
      settings.margin_per_label = s.margin_per_label || settings.margin_per_label;
      el('datasetRoot').value = settings.dataset_root;
      el('clipDuration').value = settings.clip_duration;
      el('clipMode').value = settings.clip_mode;
      el('labelThreshold').value = settings.target_per_label;
      el('labelMargin').value = settings.margin_per_label;
    }
    async function saveSettings() {
      const fd = new FormData();
      fd.append('dataset_root', el('datasetRoot').value);
      fd.append('clip_duration', el('clipDuration').value);
      fd.append('clip_mode', el('clipMode').value);
      fd.append('label_threshold', el('labelThreshold').value);
      fd.append('label_margin', el('labelMargin').value);
      const r = await fetch('/api/settings', { method: 'POST', body: fd });
      const s = await r.json();
      settings.dataset_root = s.dataset_root;
      settings.clip_duration = s.clip_duration;
      settings.clip_mode = s.clip_mode;
      log(`Saved settings`);
      await renderQuickLabels();
    }

    function log(msg) {
      const n = document.createElement('div');
      n.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      el('log').prepend(n);
    }

    async function renderQuickLabels() {
      const dl = el('labelsDatalist');
      dl.innerHTML = '';
      const container = el('quickLabels');
      container.innerHTML = '';
      // Fetch stats to color buttons and show counts
      let stats = null;
      try {
        const thr = Number(el('labelThreshold').value || settings.target_per_label);
        const mar = Number(el('labelMargin').value || settings.margin_per_label);
        const r = await fetch(`/api/label_stats?threshold=${thr}&margin=${mar}`);
        stats = await r.json();
      } catch (_) { stats = null; }
      // Draw mini chart near the header
      renderLabelMiniChart(stats);
      const byLabel = new Map();
      if (stats && stats.items) {
        for (const it of stats.items) byLabel.set(it.label, it);
      }
      lastLabels.forEach((l, idx) => {
        const o = document.createElement('option');
        o.value = l; dl.appendChild(o);
        const b = document.createElement('button');
        // hotkey: show 1,2,...,10,11,... (multi-digit supported)
        const hk = String(idx + 1);
        let txt = l;
        const it = byLabel.get(l);
        if (it && typeof it.count === 'number') txt = `${l} (${it.count})`;
        // label text
        b.textContent = txt;
        // hotkey badge
        if (hk) {
          const badge = document.createElement('span');
          badge.className = 'hotkey-badge';
          badge.textContent = hk;
          b.appendChild(badge);
          b.title = `Press ${hk} to export clip with label "${l}"`;
        } else {
          b.title = l;
        }
        b.onclick = () => { labelInput.value = l; };
        if (it && it.status) b.classList.add(`status-${it.status}`);
        container.appendChild(b);
      });
    }

    function renderLabelMiniChart(stats) {
      const chart = el('labelMiniChart');
      if (!chart) return;
      chart.innerHTML = '';
      const itemsByLabel = new Map();
      let maxCount = 0;
      if (stats && stats.items && stats.items.length) {
        for (const it of stats.items) {
          itemsByLabel.set(it.label, it);
          if (typeof it.count === 'number') maxCount = Math.max(maxCount, it.count);
        }
      }
      if (!lastLabels || lastLabels.length === 0) return;
      const H = 25; // px
      for (const label of lastLabels) {
        const it = itemsByLabel.get(label) || { count: 0, status: null };
        const n = typeof it.count === 'number' ? it.count : 0;
        const h = maxCount > 0 ? Math.max(2, Math.round((n / maxCount) * H)) : 2;
        const bar = document.createElement('div');
        bar.className = 'bar' + (it.status ? ` status-${it.status}` : '');
        bar.style.height = `${h}px`;
        bar.title = `${label}: ${n}`;
        const cnt = document.createElement('span');
        cnt.className = 'cnt' + (h < 12 ? ' tiny' : '');
        cnt.textContent = String(n);
        bar.appendChild(cnt);
        chart.appendChild(bar);
      }
    }

    async function refreshLabels() {
      const r = await fetch('/api/labels');
      const j = await r.json();
      lastLabels = j.labels || [];
      await renderQuickLabels();
    }

    async function refreshVideos() {
      const r = await fetch('/api/videos');
      const j = await r.json();
      const list = el('videoList');
      list.innerHTML = '';
      j.videos.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v; opt.textContent = v; opt.title = v; list.appendChild(opt);
      });
      if (j.videos.length && !currentVideo) {
        loadVideo(j.videos[0]);
      }
    }

    function loadVideo(name) {
      currentVideo = name;
      fileName.textContent = name;
      fileName.title = name;
      player.src = `/videos/${encodeURIComponent(name)}`;
      player.load();
      player.onloadedmetadata = () => {
        updateSeekFromVideo();
        updateTimeLabel();
      }
    }

    function updateSeekFromVideo() {
      if (!player.duration || !isFinite(player.duration)) return;
      if (isSeeking) return; // don't fight user dragging
      const v = Math.round((player.currentTime / player.duration) * 1000);
      seek.value = String(isFinite(v) ? v : 0);
    }
    function updateVideoFromSeek() {
      if (!player.duration || !isFinite(player.duration)) return;
      const t = (Number(seek.value) / 1000) * player.duration;
      if (isFinite(t)) player.currentTime = t;
      updateTimeLabel();
    }
    function updateTimeLabel() {
      timeLabel.textContent = `${fmt(player.currentTime)} / ${fmt(player.duration || 0)}`;
    }

    function togglePlayPause() {
      if (player.paused) player.play(); else player.pause();
    }

    function commitDigitBuffer() {
      if (!digitBuffer) return;
      let str = digitBuffer;
      let n = parseInt(str, 10);
      if (str === '0') n = 10; // allow single 0 as 10th label
      digitBuffer = '';
      if (digitTimer) { clearTimeout(digitTimer); digitTimer = null; }
      if (!Number.isNaN(n) && n >= 1) {
        const idx = n - 1;
        if (lastLabels[idx]) {
          doClip('auto', lastLabels[idx]);
          return;
        }
      }
      log(`No quick label for index` + (str ? ` ${str}` : ''));
    }

    function scheduleDigitCommit() {
      if (digitTimer) clearTimeout(digitTimer);
      digitTimer = setTimeout(() => { commitDigitBuffer(); }, 600);
    }

    function askLabel(initialValue = '') {
      return new Promise((resolve) => {
        const backdrop = document.getElementById('labelModalBackdrop');
        const input = document.getElementById('labelModalInput');
        const ok = document.getElementById('labelModalOk');
        const cancel = document.getElementById('labelModalCancel');

        let done = false;
        const cleanup = () => {
          if (done) return;
          done = true;
          backdrop.style.display = 'none';
          input.removeEventListener('keydown', onKey);
          ok.removeEventListener('click', onOk);
          cancel.removeEventListener('click', onCancel);
        };
        const onOk = () => { const v = input.value.trim(); cleanup(); resolve(v || null); };
        const onCancel = () => { cleanup(); resolve(null); };
        const onKey = (e) => {
          if (e.key === 'Enter') { e.preventDefault(); onOk(); }
          else if (e.key === 'Escape') { e.preventDefault(); onCancel(); }
        };

        input.value = initialValue || '';
        backdrop.style.display = 'flex';
        input.focus();
        input.select();
        input.addEventListener('keydown', onKey);
        ok.addEventListener('click', onOk);
        cancel.addEventListener('click', onCancel);
      });
    }

    async function doClip(mode = 'auto', overrideLabel = null) {
      if (!currentVideo) { log('No video loaded'); return; }
      let chosen = overrideLabel;
      if (!chosen) {
        if (!labelInput.value && lastLabels.length) {
          labelInput.value = lastLabels[lastLabels.length - 1];
        }
        const label = await askLabel(labelInput.value || '');
        if (label == null || label.trim() === '') return; // canceled
        chosen = label.trim();
      }
      labelInput.value = chosen;

      const body = {
        video_filename: currentVideo,
        current_time: player.currentTime,
        label: chosen,
        in_mark: markIn,
        out_mark: markOut,
      };
      const r = await fetch('/api/clip', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      const j = await r.json();
      if (j.ok) {
        log(`Exported clip to ${j.path}`);
        await refreshLabels();
      } else {
        log('Clip failed');
      }
    }

    async function undo() {
      const r = await fetch('/api/undo', { method: 'POST' });
      const j = await r.json();
      if (j.ok) log('Undid last clip');
    }

    // Event wiring
    el('saveSettings').onclick = saveSettings;
    el('refreshStats').onclick = async () => { await renderQuickLabels(); log('Stats refreshed'); };
    el('quitServer').onclick = async () => {
      try {
        await fetch('/api/quit', { method: 'POST' });
      } catch (e) { }
      // Give the server a moment to exit
      setTimeout(() => { window.close(); }, 200);
    };
    el('openBtn').onclick = async () => {
      const f = el('fileInput').files && el('fileInput').files[0];
      if (!f) { log('Pick a file'); return; }
      const fd = new FormData(); fd.append('file', f);
      const r = await fetch('/api/upload', { method: 'POST', body: fd });
      const j = await r.json();
      if (j.filename) {
        log(`Uploaded ${j.filename}`);
        await refreshVideos();
        loadVideo(j.filename);
      }
    };
    el('videoList').onchange = (e) => loadVideo(e.target.value);

    // Toggle native controls for debug
    el('toggleControls').addEventListener('change', (e) => {
      if (e.target.checked) player.setAttribute('controls', ''); else player.removeAttribute('controls');
    });

    // Seek UI (pause while dragging, jump on click)
    seek.addEventListener('mousedown', () => {
      isSeeking = true;
      wasPlaying = !player.paused;
      if (wasPlaying) player.pause();
    });
    seek.addEventListener('touchstart', () => {
      isSeeking = true; wasPlaying = !player.paused; if (wasPlaying) player.pause();
    }, { passive: true });
    seek.addEventListener('input', updateVideoFromSeek);
    seek.addEventListener('mouseup', () => {
      isSeeking = false; updateVideoFromSeek(); if (wasPlaying) player.play();
    });
    seek.addEventListener('touchend', () => {
      isSeeking = false; updateVideoFromSeek(); if (wasPlaying) player.play();
    });
    seek.addEventListener('click', () => { updateVideoFromSeek(); });
    player.addEventListener('timeupdate', () => { updateSeekFromVideo(); updateTimeLabel(); });

    // Buttons
    el('btnPlay').onclick = () => togglePlayPause();
    el('btnBack').onclick = () => { player.currentTime = Math.max(0, player.currentTime - 1.0); updateSeekFromVideo(); };
    el('btnBackSmall').onclick = () => { player.currentTime = Math.max(0, player.currentTime - 0.25); updateSeekFromVideo(); };
    el('btnFwdSmall').onclick = () => { player.currentTime = Math.min(player.duration || 0, player.currentTime + 0.25); updateSeekFromVideo(); };
    el('btnFwd').onclick = () => { player.currentTime = Math.min(player.duration || 0, player.currentTime + 1.0); updateSeekFromVideo(); };
    el('btnSpeed').onclick = () => {
      const speeds = [0.5, 1.0, 1.5, 2.0];
      const idx = (speeds.indexOf(player.playbackRate) + 1) % speeds.length;
      player.playbackRate = speeds[idx];
      el('btnSpeed').textContent = `${player.playbackRate.toFixed(1)}x`;
    };
    el('btnSetIn').onclick = () => { markIn = player.currentTime; el('markIn').textContent = `I: ${markIn.toFixed(2)}s`; };
    el('btnSetOut').onclick = () => { markOut = player.currentTime; el('markOut').textContent = `O: ${markOut.toFixed(2)}s`; };
    el('btnClipRange').onclick = () => doClip('range');
    el('btnUndo').onclick = undo;

    // Keyboard shortcuts (add number hotkeys for quick export)
    window.addEventListener('keydown', (e) => {
      const activeTag = document.activeElement.tagName;
      const editing = ['INPUT', 'TEXTAREA'].includes(activeTag);
      if (!editing && e.code === 'Space') { e.preventDefault(); togglePlayPause(); return; }
      if (!editing && e.code === 'Enter') {
        if (digitBuffer) { e.preventDefault(); commitDigitBuffer(); return; }
        e.preventDefault(); doClip(); return;
      }
      if (editing) return;
      if (e.code === 'ArrowLeft') { e.preventDefault(); player.currentTime = Math.max(0, player.currentTime - (e.shiftKey ? 1.0 : 0.25)); return; }
      if (e.code === 'ArrowRight') { e.preventDefault(); player.currentTime = Math.min(player.duration || 0, player.currentTime + (e.shiftKey ? 1.0 : 0.25)); return; }
      const k = e.key;
      if (k === 'j' || k === 'J') { player.playbackRate = 0.5; el('btnSpeed').textContent = '0.5x'; return; }
      if (k === 'k' || k === 'K') { player.playbackRate = 1.0; el('btnSpeed').textContent = '1.0x'; return; }
      if (k === 'l' || k === 'L') { player.playbackRate = 1.5; el('btnSpeed').textContent = '1.5x'; return; }
      if (k === 'u' || k === 'U') { undo(); return; }
      if (k === 'i' || k === 'I') { markIn = player.currentTime; el('markIn').textContent = `I: ${markIn.toFixed(2)}s`; return; }
      if (k === 'o' || k === 'O') { markOut = player.currentTime; el('markOut').textContent = `O: ${markOut.toFixed(2)}s`; return; }
      if (k === 'c' || k === 'C') { doClip('range'); return; }
      // digit hotkeys: build a multi-digit buffer and auto-commit
      if (k >= '0' && k <= '9') { e.preventDefault(); digitBuffer += k; scheduleDigitCommit(); return; }
      // '-' quick-commit removed
    });

    // Boot
    (async function init() {
      await fetchSettings();
      await refreshLabels();
      await refreshVideos();
      player.playbackRate = 1.0; el('btnSpeed').textContent = '1.0x';
    })();
  </script>
</body>

</html>